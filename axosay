#!/usr/bin/env python
from time import sleep
import random
import threading
import sys
import os
import re
import subprocess
from blessed import Terminal
import argparse
import textwrap
term = Terminal()

# # # USER SETTINGS # # #
bubble_char = '.'
animation_mouth_line = 4
frame_rate = 0.17
h_padding_int = 2
v_padding_int = 1
art_max_width = 19 #edge to edge of ascii size
art_max_height = 12
text_max_height = term.height - 2
# # # END USER SETTINGS # # #


space_for_text = (term.width - art_max_width) - h_padding_int*2
space_for_art = (term.width - space_for_text) - h_padding_int*2
parser = argparse.ArgumentParser()
parser.add_argument("-s", "--speed", default='0.005', help="Speed at which text is printed to screen by axolotl")
parser.add_argument("-t", "--timeout", default='', help="Automatically end after a number of seconds")
parser.add_argument("-c", "--character", default='axolotl', help="Animated character to select (default: axolotl)")
parser.add_argument('strings', metavar='String', type=str, nargs='+', help='a space seperated, quoted string for each page')
args = parser.parse_args()
#print(args.strings)
speed = float(args.speed)
animation_folder_path = "resources/animated/{}/".format(args.character)
alphabet = " abcdefghijklmnopqrstiuvwxyz"
homedir = os.path.expanduser("~")
text_rendered = False #flag 
text_end_line = 0
text_wrapped_continued = []
single_line_end = ''
#wrapper = textwrap.TextWrapper(width=space_for_text, max_lines=text_max_height-v_padding_int, subsequent_indent=' ')
#wrapper = textwrap.TextWrapper(width=space_for_text, max_lines=text_max_height-v_padding_int)

blank_text_line = ''
for space in range(0,space_for_text):
    blank_text_line = blank_text_line + ' '
blank_space = ''
for space in range(0,term.width):
    blank_space = blank_space + ' '
h_padding = ''
for space in range(0,h_padding_int):
    h_padding = h_padding + ' '
v_padding = ''
for space in range(v_padding_int):
    v_padding = v_padding + ' '

def check_term():
    if term.height < art_max_height:
        print("Term size needs to be at least " + str(art_max_height) + " by " + str(art_max_width + 5))
        exit()

def load_art(ascii_path):
    with open(ascii_path) as file:
        data = file.readlines()
    return data

def load_frames(animation_file_paths):
    animation = []
    for path in animation_file_paths:
            file = load_art(path)
            animation.append(file)
    return animation

def wrap_text(text):
    #after x lines append to second obj
    #cleaned_text = text
    cleaned_text = re.sub('\s+',' ',text) 
    wrapped_lines = textwrap.wrap(cleaned_text,width=space_for_text -1, max_lines=text_max_height-v_padding_int, initial_indent='',subsequent_indent='', replace_whitespace=True, expand_tabs=False)
    return wrapped_lines

def pad_text(text_wrapped):
    global text_end_line
    global text_wrapped_p2
    global single_line_end
    text_wrapped_p2 = []
 #   text_wrapped.insert(0, blank_text_line)
  #  text_wrapped.append(v_padding)
    if len(text_wrapped) == 1:
        single_line_end = len(text_wrapped[0])
        return text_wrapped
    for line in range(0,len(text_wrapped)):
        #text_wrapped[line] = text_wrapped[line].strip() 
        while len(text_wrapped[line]) < space_for_text:
            text_wrapped[line] = text_wrapped[line] + " " #pad out the empty space
            text_end_line = line
    while len(text_wrapped) > text_max_height:
        # insert as extra page here! pseudo code below
        #page = page + 1
        #args.strings[page -1]insert(text_wrapped.pop(len(text_wrapped))
        text_wrapped_continued += text_wrapped.pop(len(text_wrapped))
    while len(text_wrapped) < text_max_height:
        text_wrapped.append(blank_text_line)
    return text_wrapped

def get_file_paths():
    animation_file_paths = [os.path.join(r,file) for r,d,f in os.walk(animation_folder_path) for file in f]
    return animation_file_paths
    
def line_erase(line):
    txt_erase = term.move_y(line) + ' '
    print(term.move_xy(0, line) + blank_space,end='',flush=True)

def randomdelay():
    #delaytime = random.uniform(0.00001,speed)
    delaytime = random.uniform(speed,speed)
    return delaytime

def draw_speech_bubble():
    # speech arrows
    if single_line_end == '': #if textwrap not single line
        print(term.move_xy(space_for_text + 3,animation_mouth_line) + "--",end='',flush=True)
            #right side vertical
        for y in range(1,text_end_line + 2):
            print(term.move_xy(space_for_text + 2,y) + bubble_char,end='',flush=True)
            #bottom and top horizontal
        for x in range(space_for_text + 1, 1, -1):
            print(term.move_xy(x,0) + bubble_char,end='',flush=True)
            print(term.move_xy(x,text_end_line + 2) + bubble_char,end='',flush=True)
            sleep(0.01)
            #left side vertical
        for y in range(1, text_end_line + 2):
            print(term.move_xy(0,y) + bubble_char,end='',flush=True)
    else: # textwrap / input is single line!
        print(term.move_xy(space_for_text + 1,animation_mouth_line) + "-----",end='',flush=True)
            #right side vertical
        for y in range(1,text_end_line + 2):
            print(term.move_xy(single_line_end + 4,y) + bubble_char,end='',flush=True)
            #bottom and top horizontal
        for x in range(single_line_end + 1, 0, -1):
            print(term.move_xy(x,0) + bubble_char,end='',flush=True)
            print(term.move_xy(x,text_end_line + 2) + bubble_char,end='',flush=True)
            sleep(0.01)
            #left side vertical
        for y in range(1, text_end_line + 2):
            print(term.move_xy(0,y) + bubble_char,end='',flush=True)
 
def clear_bubble_and_text():
    print(term.move_xy(space_for_text + 3,animation_mouth_line) + "  ",end='',flush=True)
    #right side vertical
    for y in range(1,text_end_line + 2):
        print(term.move_xy(space_for_text + 2,y) + " ",end='',flush=True)
        #bottom and top horizontal
    for x in range(1,space_for_text + 2):
        print(term.move_xy(x,0) + " ",end='',flush=True)
        print(term.move_xy(x,text_end_line + 2) + " ",end='',flush=True)
        sleep(0.005)
        #left side vertical
    for y in range(1, text_end_line + 2):
        print(term.move_xy(0,y) + " ",end='',flush=True)
    for y in range(0, text_end_line + 2): #text_max_height):
        for x in range(0, space_for_text):
            print(term.move_xy(x + h_padding_int ,y + v_padding_int) + ' ',end='',flush=True)
            sleep(0.001)

def clear_text_in_bubble():
    for y in range(0, text_max_height):
        for x in range(0, space_for_text):
            print(term.move_xy(x + h_padding_int ,y + v_padding_int) + ' ',end='',flush=True)

def render_text(text_wrapped):
    if single_line_end == '':
        for y in range(0, text_max_height):
            for x in range(0, space_for_text):
                #first print a bunch of random chars as if scrolling
                for scroll_char in alphabet:
                    print(term.move_xy(x + h_padding_int ,y + v_padding_int) + scroll_char)
                    if scroll_char == text_wrapped[y][x].lower(): #scroll till correct character
                        break
                    sleep(randomdelay())
                sleep(randomdelay())
                print(term.move_xy(x + h_padding_int ,y + v_padding_int) + ' ',end='',flush=True)
                print(term.move_xy(x + h_padding_int ,y + v_padding_int) + text_wrapped[y][x],end='',flush=True)
                if text_wrapped[y] == blank_text_line:
                    break
    else:
        for x in range(0, single_line_end):
                #first print a bunch of random chars as if scrolling
                for temp_char in alphabet:
                    print(term.move_xy(x + h_padding_int ,v_padding_int) + temp_char)
                    if temp_char == text_wrapped[0][x].lower(): #scroll till correct character
                        break
                    sleep(randomdelay())
                print(term.move_xy(x + h_padding_int ,v_padding_int) + text_wrapped[0][x],end='',flush=True)

def render_animation(animation):
    while True:
        for frame_number in range(0,len(animation)):
            for y in range(0,art_max_height):
                for x in range(0, space_for_art):
                    targetx = x + space_for_text + 5
                    print(term.move_xy(targetx,y) + animation[frame_number][y][x])
            sleep(frame_rate)

def start_animation_thread(animation):
    global animate
    animate = threading.Thread(target=render_animation, args=(animation,))
    animate.daemon = True
    animate.start()

    ## TODO: ADD THREAD FOR TEXT RENDER PROCESS

def redraw_for_new_speech(text_padded): 
    text_rendered = False
    draw_speech_bubble()
    render_text(text_padded)

def next_page(page):
    clear_bubble_and_text()
    text_wrapped = wrap_text(term.strip_seqs(args.strings[page].strip()))
    text_padded = pad_text(text_wrapped)
    redraw_for_new_speech(text_padded)

def main():
    animation_file_paths = get_file_paths()
    animation = load_frames(animation_file_paths)
    text_wrapped = [] #init list
    if args.strings:
        text_wrapped = wrap_text(term.strip_seqs(args.strings[0]))
        text_padded = pad_text(text_wrapped)
    else:
        text_padded = ['']
        print("Nothing to say!")
        exit()
    text_rendered = False
    with term.cbreak(), term.hidden_cursor(), term.fullscreen():  
        start_animation_thread(animation)
        if not text_rendered:
            draw_speech_bubble()
            render_text(text_padded)
            text_rendered = True
        while True:
            if args.timeout:
                sleep(float(args.timeout))
                print(term.exit_fullscreen())
                exit()
            else:
                sleep(1)
            page = 0
            with term.cbreak():
                val = ''
                while val.lower() != 'q':
                    if page == len(args.strings)-1: # if on last page of text
                        line_erase(text_max_height + 1)
                        print(term.move_xy(0,text_max_height + 1) + "'r' restart, 'q' quit.",end='',flush=True)
                    else:
                        line_erase(text_max_height + 1)
                        print(term.move_xy(0,text_max_height + 1) + "'n' next page, 'r' restart, 'q' quit.",end='',flush=True)
                    val = term.inkey(timeout=5)
                    if not val:
                       continue
                   # elif val.is_sequence:
                    #    print("got sequence: {0}.".format((str(val), val.name, val.code)))
                    elif val == 'r':
                        line_erase(text_max_height + 1)
                        print(term.move_xy(0,text_max_height + 1) + "Restarting from 1st page...",end='',flush=True)
                        page = 0
                        next_page(page)
                    elif val == 'n':
                        line_erase(text_max_height + 1)
                        print(term.move_xy(0,text_max_height + 1) + "loading next page...",end='',flush=True)
                        if page == len(args.strings):
                            line_erase(text_max_height + 1)
                            print(term.move_xy(0,text_max_height + 1) + "Reached end, 'r' to restart or 'q' to quit",end='',flush=True)
                            sleep(0.5)
                        elif page == (len(args.strings) - 1):
                            line_erase(text_max_height + 1)
                            print(term.move_xy(0,text_max_height + 1) + "Reached end, 'r' to restart or 'q' to quit",end='',flush=True)
                            page = page + 1
                            sleep(0.5)
                        else:
                            page = page + 1
                            next_page(page)
                    elif val == 'q':
                        print(f'bye!{term.normal}')
                        print(term.exit_fullscreen())
                        exit()

if __name__ == "__main__":
    try:
        #print(term.enter_fullscreen())
        check_term()
        main()
    except Exception as e:
        print("Oops!", e.__class__, "occurred.")
    finally:
        #animate.raise_exception()
       # animate.join()
        print(term.exit_fullscreen())
        exit()
            
